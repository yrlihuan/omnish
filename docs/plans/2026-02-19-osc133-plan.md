# OSC 133 Shell Integration Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add OSC 133 protocol support for precise command boundary detection with exit codes, auto-injecting bash hooks and falling back to regex detection for unsupported shells.

**Architecture:** New `Osc133Detector` in omnish-tracker parses OSC 133 escape sequences from PTY output. `CommandTracker` gains an osc133 mode that uses these events instead of regex-based `PromptDetector`. Client strips OSC 133 sequences before writing to stdout and injects a bash hook script via `BASH_ENV`.

**Tech Stack:** Rust, omnish-tracker, omnish-client, omnish-store (CommandRecord extension)

---

### Task 1: Add `exit_code` field to `CommandRecord`

**Files:**
- Modify: `crates/omnish-store/src/command.rs:6-16`

**Step 1: Add field to CommandRecord**

In `crates/omnish-store/src/command.rs`, add `exit_code: Option<i32>` after `stream_length`:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommandRecord {
    pub command_id: String,
    pub session_id: String,
    pub command_line: Option<String>,
    pub cwd: Option<String>,
    pub started_at: u64,
    pub ended_at: Option<u64>,
    pub output_summary: String,
    pub stream_offset: u64,
    pub stream_length: u64,
    pub exit_code: Option<i32>,
}
```

**Step 2: Fix all compilation errors**

Every place that constructs a `CommandRecord` needs `exit_code: None` added. Known sites:
- `crates/omnish-tracker/src/command_tracker.rs:97` — the `completed.push(CommandRecord { ... })` block
- `crates/omnish-client/src/main.rs` — test helpers that construct `CommandRecord`
- `crates/omnish-daemon/src/session_mgr.rs` — if any test constructs one

Run: `cargo build --workspace 2>&1 | head -50`
Fix all errors by adding `exit_code: None` to each construction site.

**Step 3: Run tests**

Run: `cargo test --workspace`
Expected: all existing tests pass (field defaults to None, serde handles missing field in old JSON via `#[serde(default)]`).

Note: Add `#[serde(default)]` to the `exit_code` field for backwards compat with existing `commands.json` files:
```rust
    #[serde(default)]
    pub exit_code: Option<i32>,
```

**Step 4: Commit**

```bash
git add -A && git commit -m "feat(store): add exit_code field to CommandRecord"
```

---

### Task 2: Create `Osc133Detector` in omnish-tracker

**Files:**
- Create: `crates/omnish-tracker/src/osc133_detector.rs`
- Modify: `crates/omnish-tracker/src/lib.rs`

**Step 1: Write tests first**

Create `crates/omnish-tracker/src/osc133_detector.rs` with the following test cases:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prompt_start() {
        let mut d = Osc133Detector::new();
        let events = d.feed(b"\x1b]133;A\x07");
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0].kind, Osc133EventKind::PromptStart));
    }

    #[test]
    fn test_command_start() {
        let mut d = Osc133Detector::new();
        let events = d.feed(b"\x1b]133;B\x07");
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0].kind, Osc133EventKind::CommandStart));
    }

    #[test]
    fn test_output_start() {
        let mut d = Osc133Detector::new();
        let events = d.feed(b"\x1b]133;C\x07");
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0].kind, Osc133EventKind::OutputStart));
    }

    #[test]
    fn test_command_end_with_exit_code() {
        let mut d = Osc133Detector::new();
        let events = d.feed(b"\x1b]133;D;0\x07");
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0].kind, Osc133EventKind::CommandEnd { exit_code: 0 }));
    }

    #[test]
    fn test_command_end_nonzero() {
        let mut d = Osc133Detector::new();
        let events = d.feed(b"\x1b]133;D;127\x07");
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0].kind, Osc133EventKind::CommandEnd { exit_code: 127 }));
    }

    #[test]
    fn test_sequence_split_across_chunks() {
        let mut d = Osc133Detector::new();
        assert!(d.feed(b"\x1b]133;").is_empty());
        let events = d.feed(b"A\x07");
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0].kind, Osc133EventKind::PromptStart));
    }

    #[test]
    fn test_embedded_in_output() {
        let mut d = Osc133Detector::new();
        let events = d.feed(b"some output\x1b]133;A\x07more output");
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].start, 11);
        assert_eq!(events[0].end, 19); // 11 + len("\x1b]133;A\x07") = 11+8
    }

    #[test]
    fn test_multiple_events_in_one_chunk() {
        let mut d = Osc133Detector::new();
        let events = d.feed(b"\x1b]133;D;0\x07\x1b]133;A\x07");
        assert_eq!(events.len(), 2);
        assert!(matches!(events[0].kind, Osc133EventKind::CommandEnd { exit_code: 0 }));
        assert!(matches!(events[1].kind, Osc133EventKind::PromptStart));
    }

    #[test]
    fn test_ignores_other_osc_sequences() {
        let mut d = Osc133Detector::new();
        // OSC 0 (set title) should not produce events
        let events = d.feed(b"\x1b]0;my title\x07");
        assert!(events.is_empty());
    }

    #[test]
    fn test_strip_sequences() {
        let input = b"before\x1b]133;A\x07prompt$ \x1b]133;B\x07\x1b]133;C\x07output\x1b]133;D;0\x07";
        let stripped = strip_osc133(input);
        assert_eq!(stripped, b"beforeprompt$ output");
    }
}
```

**Step 2: Implement Osc133Detector**

```rust
/// Events emitted by the OSC 133 detector.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Osc133EventKind {
    PromptStart,
    CommandStart,
    OutputStart,
    CommandEnd { exit_code: i32 },
}

#[derive(Debug, Clone)]
pub struct Osc133Event {
    pub kind: Osc133EventKind,
    /// Byte offset in the input where this sequence starts.
    pub start: usize,
    /// Byte offset in the input where this sequence ends (exclusive).
    pub end: usize,
}

pub struct Osc133Detector {
    /// Buffer for accumulating a partial OSC sequence across chunks.
    buf: Vec<u8>,
    /// True when we're inside an ESC ] sequence.
    in_osc: bool,
    /// Byte offset where the current sequence started (relative to current feed() call).
    seq_start: usize,
    /// Total bytes consumed across previous feed() calls while in a partial sequence.
    /// Used to calculate the correct `start` offset when a sequence spans chunks.
    carried_len: usize,
}
```

State machine logic:
- On `0x1b`: if not already in OSC, record position, set `in_osc` candidate
- On `]` after ESC: confirm OSC start, begin buffering
- Buffer bytes until `0x07` (BEL) terminator
- On BEL: parse buffer. If starts with `133;`, extract event type (A/B/C/D;code)
- Reset state after BEL or if sequence is clearly not OSC 133

**Step 3: Implement `strip_osc133` utility**

```rust
/// Strip all OSC 133 sequences from a byte buffer.
/// Used to clean terminal output before displaying to user.
pub fn strip_osc133(data: &[u8]) -> Vec<u8> {
    let mut result = Vec::with_capacity(data.len());
    let mut detector = Osc133Detector::new();
    let events = detector.feed(data);

    if events.is_empty() {
        return data.to_vec();
    }

    let mut pos = 0;
    for event in &events {
        if event.start > pos {
            result.extend_from_slice(&data[pos..event.start]);
        }
        pos = event.end;
    }
    if pos < data.len() {
        result.extend_from_slice(&data[pos..]);
    }
    result
}
```

**Step 4: Register module**

In `crates/omnish-tracker/src/lib.rs`:
```rust
pub mod command_tracker;
pub mod osc133_detector;
pub mod prompt_detector;
```

**Step 5: Run tests**

Run: `cargo test -p omnish-tracker`
Expected: all tests pass.

**Step 6: Commit**

```bash
git add -A && git commit -m "feat(tracker): add Osc133Detector for shell integration protocol"
```

---

### Task 3: Add OSC 133 mode to `CommandTracker`

**Files:**
- Modify: `crates/omnish-tracker/src/command_tracker.rs`

**Step 1: Write tests**

Add to `command_tracker.rs` tests module:

```rust
    // --- OSC 133 mode tests ---

    #[test]
    fn test_osc133_simple_command() {
        use crate::osc133_detector::*;
        let mut tracker = make_tracker();

        // Shell sends: prompt start
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::PromptStart,
            start: 0, end: 8,
        }, 1000, 0);

        // User types and presses enter
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandStart,
            start: 0, end: 8,
        }, 1001, 50);
        tracker.feed_input(b"ls\r", 1001);

        // Output starts
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::OutputStart,
            start: 0, end: 8,
        }, 1002, 60);

        // Feed some output
        tracker.feed_output_raw(b"file.txt\r\n", 1002, 70);

        // Command ends
        let cmds = tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandEnd { exit_code: 0 },
            start: 0, end: 10,
        }, 1003, 100);

        assert_eq!(cmds.len(), 1);
        assert_eq!(cmds[0].command_line.as_deref(), Some("ls"));
        assert_eq!(cmds[0].exit_code, Some(0));
        assert_eq!(cmds[0].started_at, 1000);
        assert_eq!(cmds[0].ended_at, Some(1003));
    }

    #[test]
    fn test_osc133_nonzero_exit() {
        use crate::osc133_detector::*;
        let mut tracker = make_tracker();

        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::PromptStart, start: 0, end: 8,
        }, 1000, 0);
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandStart, start: 0, end: 8,
        }, 1001, 50);
        tracker.feed_input(b"false\r", 1001);
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::OutputStart, start: 0, end: 8,
        }, 1002, 60);
        let cmds = tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandEnd { exit_code: 1 },
            start: 0, end: 10,
        }, 1003, 100);

        assert_eq!(cmds.len(), 1);
        assert_eq!(cmds[0].exit_code, Some(1));
    }

    #[test]
    fn test_osc133_suppresses_regex_detection() {
        use crate::osc133_detector::*;
        let mut tracker = make_tracker();

        // First event activates osc133 mode
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::PromptStart, start: 0, end: 8,
        }, 1000, 0);
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandStart, start: 0, end: 8,
        }, 1001, 50);
        tracker.feed_input(b"echo $\r", 1001);
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::OutputStart, start: 0, end: 8,
        }, 1002, 60);

        // This output contains a prompt-like pattern that would trigger regex
        let regex_cmds = tracker.feed_output(b"user@host:~$ \r\n", 1002, 70);
        // In osc133 mode, regex detection should be suppressed
        assert!(regex_cmds.is_empty(), "regex should not fire in osc133 mode");

        // Only osc133 event finalizes
        let cmds = tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandEnd { exit_code: 0 },
            start: 0, end: 10,
        }, 1003, 100);
        assert_eq!(cmds.len(), 1);
    }

    #[test]
    fn test_osc133_multiple_commands() {
        use crate::osc133_detector::*;
        let mut tracker = make_tracker();

        // First command
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::PromptStart, start: 0, end: 8,
        }, 1000, 0);
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandStart, start: 0, end: 8,
        }, 1001, 50);
        tracker.feed_input(b"ls\r", 1001);
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::OutputStart, start: 0, end: 8,
        }, 1002, 60);
        let cmds1 = tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandEnd { exit_code: 0 },
            start: 0, end: 10,
        }, 1003, 100);
        assert_eq!(cmds1.len(), 1);
        assert_eq!(cmds1[0].command_id, "sess1:0");

        // Second command
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::PromptStart, start: 0, end: 8,
        }, 1004, 100);
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandStart, start: 0, end: 8,
        }, 1005, 150);
        tracker.feed_input(b"pwd\r", 1005);
        tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::OutputStart, start: 0, end: 8,
        }, 1006, 160);
        let cmds2 = tracker.feed_osc133(Osc133Event {
            kind: Osc133EventKind::CommandEnd { exit_code: 0 },
            start: 0, end: 10,
        }, 1007, 200);
        assert_eq!(cmds2.len(), 1);
        assert_eq!(cmds2[0].command_id, "sess1:1");
    }
```

**Step 2: Implement changes to CommandTracker**

Add fields to `CommandTracker`:
```rust
pub struct CommandTracker {
    session_id: String,
    cwd: Option<String>,
    detector: PromptDetector,
    pending: Option<PendingCommand>,
    next_seq: u32,
    seen_first_prompt: bool,
    osc133_mode: bool,
}
```

Add new methods:

```rust
    /// Feed an OSC 133 event. On first call, activates osc133 mode (suppresses regex).
    pub fn feed_osc133(
        &mut self,
        event: Osc133Event,
        timestamp_ms: u64,
        stream_pos: u64,
    ) -> Vec<CommandRecord> {
        self.osc133_mode = true;
        let mut completed = Vec::new();

        match event.kind {
            Osc133EventKind::PromptStart => {
                // Finalize previous command if any (handles case where D event was missed)
                if let Some(pending) = self.pending.take() {
                    if pending.entered {
                        completed.push(self.finalize_command(pending, timestamp_ms, stream_pos, None));
                    }
                }
                self.seen_first_prompt = true;
                self.pending = Some(PendingCommand {
                    seq: self.next_seq,
                    started_at: timestamp_ms,
                    stream_offset: stream_pos,
                    input_buf: Vec::new(),
                    output_lines: Vec::new(),
                    entered: false,
                });
                self.next_seq += 1;
            }
            Osc133EventKind::CommandStart => {
                if let Some(ref mut pending) = self.pending {
                    pending.entered = true;
                }
            }
            Osc133EventKind::OutputStart => {
                // Output collection starts — no special action needed,
                // feed_output_raw handles output collection
            }
            Osc133EventKind::CommandEnd { exit_code } => {
                if let Some(pending) = self.pending.take() {
                    completed.push(self.finalize_command(pending, timestamp_ms, stream_pos, Some(exit_code)));
                }
            }
        }

        completed
    }

    /// Feed raw output bytes for summary collection only (no prompt detection).
    /// Use this in osc133 mode where command boundaries come from OSC events.
    pub fn feed_output_raw(&mut self, data: &[u8], _timestamp_ms: u64, _stream_pos: u64) {
        if let Some(ref mut pending) = self.pending {
            if pending.entered {
                let stripped = strip_ansi(data);
                let text = String::from_utf8_lossy(&stripped);
                for line in text.split('\n') {
                    let trimmed = line.trim_end_matches('\r');
                    if !trimmed.is_empty() {
                        pending.output_lines.push(trimmed.to_string());
                    }
                }
            }
        }
    }
```

Extract a `finalize_command` helper (refactored from the duplicated code in `feed_output`):

```rust
    fn finalize_command(
        &self,
        pending: PendingCommand,
        timestamp_ms: u64,
        stream_pos: u64,
        exit_code: Option<i32>,
    ) -> CommandRecord {
        let command_line = extract_command_line(&pending.input_buf);
        let output_summary = make_summary(&pending.output_lines);
        let stream_length = stream_pos - pending.stream_offset;

        CommandRecord {
            command_id: format!("{}:{}", self.session_id, pending.seq),
            session_id: self.session_id.clone(),
            command_line,
            cwd: self.cwd.clone(),
            started_at: pending.started_at,
            ended_at: Some(timestamp_ms),
            output_summary,
            stream_offset: pending.stream_offset,
            stream_length,
            exit_code,
        }
    }
```

Modify existing `feed_output` to skip regex detection in osc133 mode:

```rust
    pub fn feed_output(...) -> Vec<CommandRecord> {
        // Collect output lines (unchanged)
        ...

        // Skip regex-based prompt detection in osc133 mode
        if self.osc133_mode {
            return Vec::new();
        }

        let events = self.detector.feed(data);
        ...
    }
```

Also refactor the existing CommandRecord construction in `feed_output` to use `finalize_command`.

**Step 3: Run tests**

Run: `cargo test -p omnish-tracker`
Expected: all old and new tests pass.

**Step 4: Commit**

```bash
git add -A && git commit -m "feat(tracker): add OSC 133 mode to CommandTracker"
```

---

### Task 4: Create bash hook script and injection

**Files:**
- Create: `crates/omnish-client/src/shell_hook.rs`
- Modify: `crates/omnish-client/src/main.rs:61-70`

**Step 1: Write the shell hook module**

Create `crates/omnish-client/src/shell_hook.rs`:

```rust
use std::path::PathBuf;

const BASH_HOOK: &str = r#"
# omnish shell integration — OSC 133 semantic prompts
__omnish_prompt_cmd() {
  local ec=$?
  printf '\033]133;D;%d\007' "$ec"
  printf '\033]133;A\007'
}
PROMPT_COMMAND="__omnish_prompt_cmd${PROMPT_COMMAND:+;$PROMPT_COMMAND}"

__omnish_preexec() {
  if [[ "$BASH_COMMAND" != "$PROMPT_COMMAND" ]] && [[ "$BASH_COMMAND" != __omnish_* ]]; then
    printf '\033]133;B\007'
    printf '\033]133;C\007'
  fi
}
trap '__omnish_preexec' DEBUG
"#;

/// Write the bash hook script and return the path.
/// Returns None if the shell is not bash.
pub fn install_bash_hook(shell: &str) -> Option<PathBuf> {
    if !shell.ends_with("bash") {
        return None;
    }

    let dir = dirs::data_dir()
        .unwrap_or_else(|| PathBuf::from("/tmp"))
        .join("omnish");
    std::fs::create_dir_all(&dir).ok()?;

    let path = dir.join("bash_hook.sh");
    std::fs::write(&path, BASH_HOOK).ok()?;
    Some(path)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hook_content_has_osc133_sequences() {
        assert!(BASH_HOOK.contains("133;A"));
        assert!(BASH_HOOK.contains("133;B"));
        assert!(BASH_HOOK.contains("133;C"));
        assert!(BASH_HOOK.contains("133;D"));
    }

    #[test]
    fn test_non_bash_returns_none() {
        assert!(install_bash_hook("/bin/zsh").is_none());
        assert!(install_bash_hook("/bin/fish").is_none());
    }

    #[test]
    fn test_bash_returns_path() {
        let result = install_bash_hook("/bin/bash");
        assert!(result.is_some());
        let path = result.unwrap();
        assert!(path.exists());
        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("__omnish_prompt_cmd"));
    }
}
```

**Step 2: Integrate into main.rs**

In `crates/omnish-client/src/main.rs`, add module declaration and inject env var:

```rust
mod shell_hook;
```

Before the `PtyProxy::spawn_with_env` call (~line 68-70), add:

```rust
    // Install shell hooks for OSC 133 support
    if let Some(hook_path) = shell_hook::install_bash_hook(&shell) {
        child_env.insert("BASH_ENV".to_string(), hook_path.to_string_lossy().to_string());
    }
```

**Step 3: Run tests**

Run: `cargo test -p omnish-client`
Expected: pass (shell_hook unit tests + existing tests).

**Step 4: Commit**

```bash
git add -A && git commit -m "feat(client): add bash hook injection for OSC 133"
```

---

### Task 5: Integrate OSC 133 detection into client main loop

**Files:**
- Modify: `crates/omnish-client/src/main.rs:93-278`

**Step 1: Add Osc133Detector to main loop setup**

After `let mut command_tracker = ...` (~line 97-99), add:

```rust
    let mut osc133_detector = omnish_tracker::osc133_detector::Osc133Detector::new();
```

**Step 2: Modify PTY output path**

In the PTY output read path (around line 234-281), restructure to:

1. Feed raw bytes to `osc133_detector` first
2. Strip OSC 133 sequences before writing to stdout
3. Use osc133 events to drive command tracking when available
4. Fall back to existing `feed_output` for regex mode

Replace the output handling block:

```rust
                Ok(n) => {
                    let raw = &output_buf[..n];

                    // Detect OSC 133 events
                    let osc_events = osc133_detector.feed(raw);

                    // Strip OSC 133 sequences before displaying to user
                    let display_data = if osc_events.is_empty() {
                        raw.to_vec()
                    } else {
                        omnish_tracker::osc133_detector::strip_osc133(raw)
                    };

                    nix::unistd::write(std::io::stdout(), &display_data)?;

                    // Track cursor column (on stripped data)
                    col_tracker.feed(&display_data);

                    // Detect alternate screen transitions
                    if let Some(active) = alt_screen_detector.feed(&display_data) {
                        interceptor.set_suppressed(active);
                    }

                    // Notify interceptor of output
                    interceptor.note_output(&display_data);

                    // Send IoData to daemon (throttled)
                    if let Some(ref rpc) = daemon_conn {
                        if throttle.should_send(n) {
                            let msg = Message::IoData(IoData {
                                session_id: session_id.clone(),
                                direction: IoDirection::Output,
                                timestamp_ms: timestamp_ms(),
                                data: raw.to_vec(), // send raw (including OSC 133) to daemon
                            });
                            send_or_buffer(rpc, msg, &pending_buffer).await;
                            throttle.record_sent(n);
                        }
                    }

                    // Feed OSC 133 events to command tracker
                    let mut completed = Vec::new();
                    for event in osc_events {
                        let cmds = command_tracker.feed_osc133(event, timestamp_ms(), 0);
                        completed.extend(cmds);
                    }

                    // Also feed output for summary collection + regex fallback
                    let regex_cmds = command_tracker.feed_output(raw, timestamp_ms(), 0);
                    completed.extend(regex_cmds);

                    // In osc133 mode, feed_output_raw for summary collection
                    command_tracker.feed_output_raw(raw, timestamp_ms(), 0);

                    // Send completed commands to daemon
                    for record in &completed {
                        if let Some(ref rpc) = daemon_conn {
                            let msg = Message::CommandComplete(omnish_protocol::message::CommandComplete {
                                session_id: session_id.clone(),
                                record: record.clone(),
                            });
                            send_or_buffer(rpc, msg, &pending_buffer).await;
                        }
                    }
                    if !completed.is_empty() {
                        throttle.reset();
                    }
                }
```

Note: `feed_output` already returns empty in osc133 mode, so calling both is safe. `feed_output_raw` only collects output lines when in osc133 mode and pending command has `entered=true`.

**Step 3: Build and verify**

Run: `cargo build --workspace`
Expected: compiles cleanly.

Run: `cargo test --workspace`
Expected: all tests pass.

**Step 4: Commit**

```bash
git add -A && git commit -m "feat(client): integrate OSC 133 detection in PTY output path"
```

---

### Task 6: Workspace verification

**Step 1: Full test suite**

Run: `cargo test --workspace`
Expected: all tests pass.

**Step 2: Clippy**

Run: `cargo clippy --workspace`
Expected: no warnings (or only pre-existing ones).

**Step 3: Verify build**

Run: `cargo build --workspace`
Expected: clean build.
