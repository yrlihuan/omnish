# OSC 133 Shell Integration Support

Date: 2026-02-19

## Problem

Current command detection relies on `PromptDetector` regex matching (`[\$#%❯]\s*$`), which:
- Only detects command boundaries when the next prompt appears
- Cannot provide exit codes
- Has false positive risk with output containing prompt-like patterns
- Cannot distinguish prompt-start from command-start from output-start

## Solution

Add OSC 133 semantic shell integration protocol support. Shells emit escape sequences at well-defined points in the command lifecycle, giving precise command boundaries and exit codes.

## OSC 133 Protocol

Four escape sequences emitted by shell hooks:

| Sequence | Meaning | When |
|----------|---------|------|
| `\x1b]133;A\x07` | Prompt Start | Before prompt is displayed |
| `\x1b]133;B\x07` | Command Start | User pressed Enter |
| `\x1b]133;C\x07` | Output Start | Command output begins |
| `\x1b]133;D;{exit_code}\x07` | Command End | Command finished, with exit code |

## Design

### 1. Osc133Detector (omnish-tracker)

New module in `omnish-tracker` crate alongside `PromptDetector`.

- Byte-level state machine parser (like `AltScreenDetector`)
- Handles sequences split across read() chunks
- Emits `Osc133Event` enum variants: `PromptStart`, `CommandStart`, `OutputStart`, `CommandEnd { exit_code: i32 }`
- Also reports byte ranges of matched sequences for stripping from terminal output

### 2. CommandTracker Changes

- New method: `feed_osc133(&mut self, event: Osc133Event, timestamp_ms: u64, stream_pos: u64) -> Vec<CommandRecord>`
- On first OSC 133 event received, sets `osc133_mode = true`
- In osc133 mode, `PromptDetector` results are ignored
- Command lifecycle in osc133 mode:
  - `A` (PromptStart) → finalize previous command if any, start new pending
  - `B` (CommandStart) → mark `entered = true`
  - `C` (OutputStart) → begin collecting output
  - `D;code` (CommandEnd) → finalize with exit code
- Falls back to regex detection if no OSC 133 sequences are seen

### 3. CommandRecord Extension

Add `exit_code: Option<i32>` field. Set to `None` in regex mode, `Some(code)` in osc133 mode.

### 4. Shell Hook Injection (bash only, initial scope)

Client injects hooks before spawning the child shell.

**Mechanism:** Write `~/.local/share/omnish/bash_hook.sh`, set `BASH_ENV` environment variable to point to it. The hook file contains:

```bash
__omnish_prompt_cmd() {
  local ec=$?
  printf '\033]133;D;%d\007' "$ec"
  printf '\033]133;A\007'
}
PROMPT_COMMAND="__omnish_prompt_cmd${PROMPT_COMMAND:+;$PROMPT_COMMAND}"

__omnish_preexec() {
  printf '\033]133;B\007'
  printf '\033]133;C\007'
}
trap '__omnish_preexec' DEBUG
```

### 5. Client Integration

In the PTY output read path:

1. Feed raw bytes to `Osc133Detector`
2. If events produced, feed to `CommandTracker.feed_osc133()`
3. Strip OSC 133 sequences from output before writing to user's terminal
4. Continue feeding to `PromptDetector` via `feed_output()` (ignored internally when in osc133 mode)

### 6. Coexistence Strategy

- OSC 133 takes priority when detected
- `PromptDetector` regex serves as fallback for shells without hooks
- Auto-detection: first OSC 133 event switches the mode, no configuration needed

## Scope

- Initial: bash only
- Future: zsh (precmd/preexec), fish (fish_prompt/fish_preexec)
